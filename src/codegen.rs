use std::collections::HashSet;
use std::io::{Seek, SeekFrom, Write};

use serde_json::Value as JsonValue;

use crate::convex::{ConvexFunction, ConvexFunctions, ConvexSchema, ConvexTable};
use crate::errors::ConvexTypeGeneratorError;

// =============================================================================
// CodegenContext — accumulates inline struct/enum definitions during generation
// =============================================================================

struct CodegenContext<'a>
{
    tables: &'a [ConvexTable],
    extra_structs: Vec<String>,
    generated_names: HashSet<String>,
}

impl<'a> CodegenContext<'a>
{
    fn new(tables: &'a [ConvexTable]) -> Self
    {
        CodegenContext {
            tables,
            extra_structs: Vec::new(),
            generated_names: HashSet::new(),
        }
    }

    /// Register a struct/enum definition. Deduplicates by name.
    /// Returns the struct name for use as a type reference.
    fn register_struct(&mut self, name: &str, code: &str) -> String
    {
        if !self.generated_names.contains(name) {
            self.generated_names.insert(name.to_string());
            self.extra_structs.push(code.to_string());
        }
        name.to_string()
    }

    /// Drain accumulated struct definitions into a single string.
    fn drain_extra_structs(&mut self) -> String
    {
        self.extra_structs.drain(..).collect()
    }
}

// =============================================================================
// Main entry point
// =============================================================================

pub(crate) fn generate_code(path: &str, data: (ConvexSchema, ConvexFunctions)) -> Result<(), ConvexTypeGeneratorError>
{
    let mut file = std::fs::File::create(path)?;

    file.set_len(0)?;
    file.seek(SeekFrom::Start(0))?;

    let file_header = r#"// This file is generated by convex-typegen. Do not modify directly.
// You can find more information about convex-typegen at https://github.com/JamalLyons/convex-typegen

#[allow(unused_imports)]
use serde::{Serialize, Deserialize};

"#;

    file.write_all(file_header.as_bytes())?;

    let mut code = String::new();
    let (schema, functions) = data;
    let mut ctx = CodegenContext::new(&schema.tables);

    // Generate table structs (enums/inline types are accumulated in ctx)
    for table in &schema.tables {
        code.push_str(&generate_table_code(table, &mut ctx));
    }

    // Emit inline types from table processing
    code.push_str(&ctx.drain_extra_structs());

    // Generate function argument types
    for function in &functions {
        code.push_str(&generate_function_code(function, &mut ctx));
    }

    // Emit inline types from function arg processing
    code.push_str(&ctx.drain_extra_structs());

    // Generate typed API trait + impl for ConvexClient
    code.push_str(&generate_api_code(&functions, &mut ctx));

    // Emit inline types from return type processing
    code.push_str(&ctx.drain_extra_structs());

    file.write_all(code.as_bytes())?;

    Ok(())
}

// =============================================================================
// Helpers
// =============================================================================

/// Check if a function parameter maps to `Option<T>` in Rust.
/// This is true for `v.optional(...)` and `v.union(..., v.null())` with exactly one non-null variant.
fn is_optional_param(param: &crate::convex::ConvexFunctionParam) -> bool
{
    match param.data_type["type"].as_str() {
        Some("optional") => true,
        Some("union") => {
            if let Some(variants) = param.data_type["variants"].as_array() {
                let null_count = variants.iter().filter(|v| v["type"].as_str() == Some("null")).count();
                let non_null_count = variants.len() - null_count;
                null_count == 1 && non_null_count == 1
            } else {
                false
            }
        }
        _ => false,
    }
}

// =============================================================================
// Type conversion (unified — handles all types including objects and unions)
// =============================================================================

/// Convert a Convex type to its corresponding Rust type.
///
/// `naming_ctx` is used to name generated structs/enums (e.g. "UsersMetadata",
/// "PhoneAuthRobotClaimAuthId"). When recursing into nested types, the context
/// is extended with the field name.
fn convex_type_to_rust_type(data_type: &JsonValue, naming_ctx: &str, ctx: &mut CodegenContext) -> String
{
    let type_str = data_type["type"].as_str().unwrap_or("unknown");

    match type_str {
        "string" => "String".to_string(),
        "number" => "f64".to_string(),
        "boolean" => "bool".to_string(),
        "null" => "()".to_string(),
        "int64" => "i64".to_string(),
        "bytes" => "Vec<u8>".to_string(),
        "any" => "serde_json::Value".to_string(),

        "array" => {
            let element_type = convex_type_to_rust_type(&data_type["elements"], naming_ctx, ctx);
            format!("Vec<{}>", element_type)
        }

        "object" => {
            if let Some(props) = data_type["properties"].as_object() {
                if props.is_empty() {
                    return "serde_json::Value".to_string();
                }
                // Try table shape match first
                if let Some(table_struct) = try_match_table_shape(props, ctx.tables) {
                    return table_struct;
                }
                // Generate a dedicated struct
                let struct_name = naming_ctx.to_string();
                let mut struct_code = String::new();
                struct_code += "#[derive(Debug, Clone, Serialize, Deserialize)]\n";
                struct_code += &format!("pub struct {} {{\n", struct_name);
                for (field_name, field_type) in props {
                    let nested_ctx = format!("{}{}", struct_name, capitalize_first_letter(field_name));
                    let rust_type = convex_type_to_rust_type(field_type, &nested_ctx, ctx);
                    let rust_name = to_snake_case(field_name);
                    if rust_name != *field_name {
                        struct_code += &format!("    #[serde(rename = \"{}\")]\n", field_name);
                    }
                    struct_code += &format!("    pub {}: {},\n", rust_name, rust_type);
                }
                struct_code += "}\n\n";
                ctx.register_struct(&struct_name, &struct_code)
            } else {
                "serde_json::Value".to_string()
            }
        }

        "record" => {
            let key_type = convex_type_to_rust_type(&data_type["keyType"], naming_ctx, ctx);
            let value_type = convex_type_to_rust_type(&data_type["valueType"], naming_ctx, ctx);
            format!("std::collections::HashMap<{}, {}>", key_type, value_type)
        }

        "optional" => {
            let inner_type = convex_type_to_rust_type(&data_type["inner"], naming_ctx, ctx);
            format!("Option<{}>", inner_type)
        }

        "union" => {
            if let Some(variants) = data_type["variants"].as_array() {
                // Nullable pattern: union(T, null) -> Option<T>
                let null_count = variants.iter().filter(|v| v["type"].as_str() == Some("null")).count();
                let non_null: Vec<&JsonValue> = variants.iter().filter(|v| v["type"].as_str() != Some("null")).collect();
                if null_count == 1 && non_null.len() == 1 {
                    let inner = convex_type_to_rust_type(non_null[0], naming_ctx, ctx);
                    return format!("Option<{}>", inner);
                }

                // Tagged union: all variants are objects with a `type` literal field
                if is_tagged_union(variants) {
                    let enum_code = generate_tagged_enum(naming_ctx, variants, ctx);
                    ctx.register_struct(naming_ctx, &enum_code);
                    return naming_ctx.to_string();
                }

                // Literal union: all variants are literals -> Copy enum
                let all_literals = variants.iter().all(|v| v["type"].as_str() == Some("literal"));
                if all_literals {
                    let enum_code = generate_simple_enum(naming_ctx, variants, ctx);
                    ctx.register_struct(naming_ctx, &enum_code);
                    return naming_ctx.to_string();
                }

                // Mixed union (e.g. string | number) -> untagged enum
                if !variants.is_empty() {
                    let enum_code = generate_simple_enum(naming_ctx, variants, ctx);
                    ctx.register_struct(naming_ctx, &enum_code);
                    return naming_ctx.to_string();
                }
            }
            "serde_json::Value".to_string()
        }

        "literal" => "String".to_string(),
        "id" => "String".to_string(),

        _ => "serde_json::Value".to_string(),
    }
}

/// Check if an object type's properties match a known table's columns.
/// When a return type is `v.object({_id: v.id("clients"), _creationTime: v.number(), ...})`,
/// we detect it matches `ClientsTable` and reuse that struct instead of generating a new one.
fn try_match_table_shape(props: &serde_json::Map<String, JsonValue>, tables: &[ConvexTable]) -> Option<String>
{
    // User-defined columns (exclude system fields)
    let user_props: std::collections::BTreeMap<&str, &JsonValue> = props
        .iter()
        .filter(|(k, _)| k.as_str() != "_id" && k.as_str() != "_creationTime")
        .map(|(k, v)| (k.as_str(), v))
        .collect();

    for table in tables {
        if table.columns.len() != user_props.len() {
            continue;
        }
        let all_match = table.columns.iter().all(|col| {
            user_props
                .get(col.name.as_str())
                .map(|p| **p == col.data_type)
                .unwrap_or(false)
        });
        if all_match {
            return Some(format!("{}Table", capitalize_first_letter(&table.name)));
        }
    }
    None
}

// =============================================================================
// Union helpers
// =============================================================================

/// Check if a union is a tagged union (all variants are objects with a `type` literal field).
fn is_tagged_union(variants: &[JsonValue]) -> bool
{
    if variants.is_empty() {
        return false;
    }
    variants.iter().all(|v| {
        if v["type"].as_str() != Some("object") {
            return false;
        }
        if let Some(props) = v["properties"].as_object() {
            props.get("type").is_some_and(|t| t["type"].as_str() == Some("literal"))
        } else {
            false
        }
    })
}

/// Generate a tagged union enum from object variants with a `type` discriminator field.
fn generate_tagged_enum(enum_name: &str, variants: &[JsonValue], ctx: &mut CodegenContext) -> String
{
    let mut code = String::new();
    code.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    code.push_str("#[serde(tag = \"type\")]\n");
    code.push_str(&format!("pub enum {} {{\n", enum_name));

    for variant in variants {
        if let Some(props) = variant["properties"].as_object() {
            let tag = props.get("type").and_then(|t| t["value"].as_str()).unwrap_or("Unknown");

            let variant_name = to_pascal_case(tag);

            // Collect non-`type` fields
            let fields: Vec<(&String, &JsonValue)> = props.iter().filter(|(k, _)| k.as_str() != "type").collect();

            if fields.is_empty() {
                code.push_str(&format!("    {},\n", variant_name));
            } else {
                code.push_str(&format!("    {} {{\n", variant_name));
                for (field_name, field_type) in &fields {
                    let nested_ctx = format!("{}{}{}", enum_name, variant_name, capitalize_first_letter(field_name));
                    let rust_type = convex_type_to_rust_type(field_type, &nested_ctx, ctx);
                    code.push_str(&format!("        {}: {},\n", field_name, rust_type));
                }
                code.push_str("    },\n");
            }
        }
    }

    code.push_str("}\n\n");
    code
}

/// Generate a simple enum from literal or mixed variants.
fn generate_simple_enum(enum_name: &str, variants: &[JsonValue], ctx: &mut CodegenContext) -> String
{
    let all_literals = variants.iter().all(|v| v["type"].as_str() == Some("literal"));

    let mut code = String::new();
    if all_literals {
        code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\n");
    } else {
        code.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
        code.push_str("#[serde(untagged)]\n");
    }
    code.push_str(&format!("pub enum {} {{\n", enum_name));

    for variant in variants {
        match variant["type"].as_str() {
            Some("literal") => {
                if let Some(value) = variant["value"].as_str() {
                    let variant_name = to_pascal_case(value);
                    if variant_name != value {
                        code.push_str(&format!("    #[serde(rename = \"{}\")]\n", value));
                    }
                    code.push_str(&format!("    {},\n", variant_name));
                }
            }
            Some(type_name) => {
                let nested_ctx = format!("{}{}", enum_name, to_pascal_case(type_name));
                let rust_type = convex_type_to_rust_type(variant, &nested_ctx, ctx);
                code.push_str(&format!("    {}({}),\n", to_pascal_case(type_name), rust_type));
            }
            None => continue,
        }
    }

    code.push_str("}\n\n");
    code
}

// =============================================================================
// Table code generation
// =============================================================================

/// Generate the struct for a table.
fn generate_table_code(table: &ConvexTable, ctx: &mut CodegenContext) -> String
{
    let mut code = String::new();

    let table_cap = capitalize_first_letter(&table.name);
    let table_struct_name = format!("{}Table", table_cap);

    code.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    code.push_str(&format!("pub struct {} {{\n", table_struct_name));

    // Convex system fields
    code.push_str("    #[serde(rename = \"_id\")]\n");
    code.push_str("    pub id: String,\n");
    code.push_str("    #[serde(rename = \"_creationTime\")]\n");
    code.push_str("    pub creation_time: f64,\n");

    for column in &table.columns {
        let naming_ctx = format!("{}{}", table_cap, capitalize_first_letter(&column.name));
        let rust_type = convex_type_to_rust_type(&column.data_type, &naming_ctx, ctx);
        let rust_name = to_snake_case(&column.name);
        if rust_name != column.name {
            code.push_str(&format!("    #[serde(rename = \"{}\")]\n", column.name));
        }
        code.push_str(&format!("    pub {}: {},\n", rust_name, rust_type));
    }

    code.push_str("}\n\n");
    code
}

// =============================================================================
// Function code generation
// =============================================================================

/// Generate the args struct for a function.
fn generate_function_code(function: &ConvexFunction, ctx: &mut CodegenContext) -> String
{
    let mut code = String::new();

    let file_cap = capitalize_first_letter(&function.file_name);
    let fn_cap = capitalize_first_letter(&function.name);
    let struct_name = format!("{}{}Args", file_cap, fn_cap);

    code.push_str("#[derive(Debug, Clone, Serialize, Deserialize)]\n");
    if !function.params.is_empty() {
        code.push_str("#[allow(non_snake_case)]\n");
    }
    code.push_str(&format!("pub struct {} {{\n", struct_name));

    for param in &function.params {
        let naming_ctx = format!("{}{}{}", file_cap, fn_cap, capitalize_first_letter(&param.name));
        let rust_type = convex_type_to_rust_type(&param.data_type, &naming_ctx, ctx);
        code.push_str(&format!("    pub {}: {},\n", param.name, rust_type));
    }

    code.push_str("}\n\n");

    // FUNCTION_PATH constant
    code.push_str(&format!("impl {} {{\n", struct_name));
    code.push_str("    pub const FUNCTION_PATH: &'static str = ");
    code.push_str(&format!("\"{}:{}\";\n", function.file_name, function.name));
    code.push_str("}\n\n");

    // From impl for BTreeMap
    code.push_str(&format!(
        "impl From<{}> for std::collections::BTreeMap<String, serde_json::Value> {{\n",
        struct_name
    ));
    code.push_str(&format!("    fn from(_args: {}) -> Self {{\n", struct_name));

    if function.params.is_empty() {
        code.push_str("        std::collections::BTreeMap::new()\n");
    } else {
        code.push_str("        let mut map = std::collections::BTreeMap::new();\n");
        for param in &function.params {
            if is_optional_param(param) {
                code.push_str(&format!(
                    "        if let Some(val) = _args.{} {{\n            map.insert(\"{}\".to_string(), \
                     serde_json::to_value(val).unwrap());\n        }}\n",
                    param.name, param.name
                ));
            } else {
                code.push_str(&format!(
                    "        map.insert(\"{}\".to_string(), serde_json::to_value(_args.{}).unwrap());\n",
                    param.name, param.name
                ));
            }
        }
        code.push_str("        map\n");
    }

    code.push_str("    }\n");
    code.push_str("}\n\n");

    code
}

// =============================================================================
// API trait generation
// =============================================================================

/// Generate the typed API trait and implementation for ConvexClient.
fn generate_api_code(functions: &[ConvexFunction], ctx: &mut CodegenContext) -> String
{
    let public_functions: Vec<&ConvexFunction> = functions.iter().filter(|f| !f.type_.starts_with("internal")).collect();

    if public_functions.is_empty() {
        return String::new();
    }

    let mut code = String::new();

    // json_to_convex_value helper (always needed for args conversion)
    code.push_str(&generate_json_to_convex_value_helper());

    // convex_value_to_json helper if any function has a typed return
    let has_typed_returns = public_functions.iter().any(|f| f.return_type.is_some());
    if has_typed_returns {
        code.push_str(&generate_convex_value_to_json_helper());
    }

    // TypedSubscription wrapper if any query has a typed return
    let has_typed_queries = public_functions.iter().any(|f| f.type_ == "query" && f.return_type.is_some());
    if has_typed_queries {
        code.push_str(&generate_typed_subscription_code());
    }

    // Trait definition
    code.push_str("#[allow(async_fn_in_trait)]\n");
    code.push_str("pub trait ConvexApi {\n");
    for func in &public_functions {
        code.push_str(&generate_trait_method(func, ctx));
    }
    code.push_str("}\n\n");

    // Impl for ConvexClient
    code.push_str("impl ConvexApi for convex::ConvexClient {\n");
    for func in &public_functions {
        code.push_str(&generate_trait_impl_method(func, ctx));
    }
    code.push_str("}\n\n");

    code
}

/// Get the Rust return type string for a function's return type.
/// Returns None if the function has no typed return (uses FunctionResult).
fn get_return_type_str(func: &ConvexFunction, ctx: &mut CodegenContext) -> Option<String>
{
    func.return_type.as_ref().map(|rt| {
        let naming_ctx = format!(
            "{}{}Return",
            capitalize_first_letter(&func.file_name),
            capitalize_first_letter(&func.name)
        );
        convex_type_to_rust_type(rt, &naming_ctx, ctx)
    })
}

/// Generate a trait method signature for a Convex function.
fn generate_trait_method(func: &ConvexFunction, ctx: &mut CodegenContext) -> String
{
    let mut code = String::new();
    let file_snake = to_snake_case(&func.file_name);
    let fn_snake = to_snake_case(&func.name);

    let args_part = if func.params.is_empty() {
        String::new()
    } else {
        let struct_name = format!(
            "{}{}Args",
            capitalize_first_letter(&func.file_name),
            capitalize_first_letter(&func.name)
        );
        format!(", args: {}", struct_name)
    };

    let return_type_str = get_return_type_str(func, ctx);
    let return_type = match &return_type_str {
        Some(rt) => format!("anyhow::Result<{}>", rt),
        None => "anyhow::Result<convex::FunctionResult>".to_string(),
    };

    match func.type_.as_str() {
        "query" => {
            // Subscribe — typed if return type available
            let sub_return = match &return_type_str {
                Some(rt) => format!("anyhow::Result<TypedSubscription<{}>>", rt),
                None => "anyhow::Result<convex::QuerySubscription>".to_string(),
            };
            code.push_str(&format!(
                "    async fn subscribe_{}_{}(&mut self{}) -> {};\n",
                file_snake, fn_snake, args_part, sub_return
            ));
            code.push_str(&format!(
                "    async fn query_{}_{}(&mut self{}) -> {};\n",
                file_snake, fn_snake, args_part, return_type
            ));
        }
        "mutation" => {
            code.push_str(&format!(
                "    async fn {}_{}(&mut self{}) -> {};\n",
                file_snake, fn_snake, args_part, return_type
            ));
        }
        "action" => {
            code.push_str(&format!(
                "    async fn {}_{}(&mut self{}) -> {};\n",
                file_snake, fn_snake, args_part, return_type
            ));
        }
        _ => {}
    }

    code
}

/// Generate a trait implementation method for a Convex function.
fn generate_trait_impl_method(func: &ConvexFunction, ctx: &mut CodegenContext) -> String
{
    let mut code = String::new();
    let file_snake = to_snake_case(&func.file_name);
    let fn_snake = to_snake_case(&func.name);
    let function_path = format!("{}:{}", func.file_name, func.name);

    let has_args = !func.params.is_empty();
    let args_param = if has_args {
        let struct_name = format!(
            "{}{}Args",
            capitalize_first_letter(&func.file_name),
            capitalize_first_letter(&func.name)
        );
        format!(", args: {}", struct_name)
    } else {
        String::new()
    };

    let args_body = if has_args {
        "        let json_args: std::collections::BTreeMap<String, serde_json::Value> = args.into();\n\x20       let args = \
         json_args.into_iter().map(|(k, v)| (k, json_to_convex_value(v))).collect();\n"
            .to_string()
    } else {
        "        let args = std::collections::BTreeMap::new();\n".to_string()
    };

    let return_type_str = get_return_type_str(func, ctx);
    let return_type = match &return_type_str {
        Some(rt) => format!("anyhow::Result<{}>", rt),
        None => "anyhow::Result<convex::FunctionResult>".to_string(),
    };

    // Generate the body that unwraps FunctionResult into the typed return
    let typed_return_body = |sdk_call: &str| -> String {
        match &return_type_str {
            Some(rt) if rt == "()" => {
                // Special case: null/unit return — no deserialization needed
                format!(
                    "        let result = self.{sdk_call}(\"{function_path}\", args).await?;\n\x20       match result \
                     {{\n\x20           convex::FunctionResult::Value(_) => Ok(()),\n\x20           \
                     convex::FunctionResult::ErrorMessage(msg) => Err(anyhow::anyhow!(msg)),\n\x20           \
                     convex::FunctionResult::ConvexError(err) => Err(anyhow::anyhow!(err.message)),\n\x20       }}\n"
                )
            }
            Some(_) => {
                // Typed return — convert Value to JSON and deserialize
                format!(
                    "        let result = self.{sdk_call}(\"{function_path}\", args).await?;\n\
                     \x20       match result {{\n\
                     \x20           convex::FunctionResult::Value(value) => {{\n\
                     \x20               let json = convex_value_to_json(&value);\n\
                     \x20               Ok(serde_json::from_value(json)?)\n\
                     \x20           }}\n\
                     \x20           convex::FunctionResult::ErrorMessage(msg) => Err(anyhow::anyhow!(msg)),\n\
                     \x20           convex::FunctionResult::ConvexError(err) => Err(anyhow::anyhow!(err.message)),\n\
                     \x20       }}\n"
                )
            }
            None => {
                // No typed return — pass through FunctionResult
                format!("        self.{sdk_call}(\"{function_path}\", args).await\n")
            }
        }
    };

    match func.type_.as_str() {
        "query" => {
            // Subscribe — typed or untyped
            let sub_return = match &return_type_str {
                Some(rt) => format!("anyhow::Result<TypedSubscription<{}>>", rt),
                None => "anyhow::Result<convex::QuerySubscription>".to_string(),
            };
            code.push_str(&format!(
                "    async fn subscribe_{file_snake}_{fn_snake}(&mut self{args_param}) -> {sub_return} {{\n"
            ));
            code.push_str(&args_body);
            if return_type_str.is_some() {
                code.push_str(&format!(
                    "        let sub = self.subscribe(\"{function_path}\", args).await?;\n\x20       \
                     Ok(TypedSubscription::new(sub))\n"
                ));
            } else {
                code.push_str(&format!("        self.subscribe(\"{function_path}\", args).await\n"));
            }
            code.push_str("    }\n");

            // Query — typed if available
            code.push_str(&format!(
                "    async fn query_{file_snake}_{fn_snake}(&mut self{args_param}) -> {return_type} {{\n"
            ));
            code.push_str(&args_body);
            code.push_str(&typed_return_body("query"));
            code.push_str("    }\n");
        }
        "mutation" => {
            code.push_str(&format!(
                "    async fn {file_snake}_{fn_snake}(&mut self{args_param}) -> {return_type} {{\n"
            ));
            code.push_str(&args_body);
            code.push_str(&typed_return_body("mutation"));
            code.push_str("    }\n");
        }
        "action" => {
            code.push_str(&format!(
                "    async fn {file_snake}_{fn_snake}(&mut self{args_param}) -> {return_type} {{\n"
            ));
            code.push_str(&args_body);
            code.push_str(&typed_return_body("action"));
            code.push_str("    }\n");
        }
        _ => {}
    }

    code
}

// =============================================================================
// Generated helper functions
// =============================================================================

/// Generate the json_to_convex_value helper function in the output.
fn generate_json_to_convex_value_helper() -> String
{
    "fn json_to_convex_value(v: serde_json::Value) -> convex::Value {\n\
     \x20   match v {\n\
     \x20       serde_json::Value::Null => convex::Value::Null,\n\
     \x20       serde_json::Value::Bool(b) => convex::Value::Boolean(b),\n\
     \x20       serde_json::Value::Number(n) => {\n\
     \x20           if let Some(i) = n.as_i64() {\n\
     \x20               convex::Value::Int64(i)\n\
     \x20           } else if let Some(f) = n.as_f64() {\n\
     \x20               convex::Value::Float64(f)\n\
     \x20           } else {\n\
     \x20               convex::Value::Null\n\
     \x20           }\n\
     \x20       }\n\
     \x20       serde_json::Value::String(s) => convex::Value::String(s),\n\
     \x20       serde_json::Value::Array(arr) => convex::Value::Array(arr.into_iter().map(json_to_convex_value).collect()),\n\
     \x20       serde_json::Value::Object(map) => {\n\
     \x20           let converted: std::collections::BTreeMap<String, convex::Value> =\n\
     \x20               map.into_iter().map(|(k, v)| (k, json_to_convex_value(v))).collect();\n\
     \x20           convex::Value::Object(converted)\n\
     \x20       }\n\
     \x20   }\n\
     }\n\n"
        .to_string()
}

/// Generate the convex_value_to_json helper function in the output.
fn generate_convex_value_to_json_helper() -> String
{
    "fn convex_value_to_json(v: &convex::Value) -> serde_json::Value {\n\
     \x20   match v {\n\
     \x20       convex::Value::Null => serde_json::Value::Null,\n\
     \x20       convex::Value::Int64(n) => serde_json::json!(*n),\n\
     \x20       convex::Value::Float64(f) => serde_json::json!(*f),\n\
     \x20       convex::Value::Boolean(b) => serde_json::json!(*b),\n\
     \x20       convex::Value::String(s) => serde_json::Value::String(s.clone()),\n\
     \x20       convex::Value::Array(arr) => serde_json::Value::Array(arr.iter().map(convex_value_to_json).collect()),\n\
     \x20       convex::Value::Object(obj) => {\n\
     \x20           let map: serde_json::Map<String, serde_json::Value> =\n\
     \x20               obj.iter().map(|(k, v)| (k.clone(), convex_value_to_json(v))).collect();\n\
     \x20           serde_json::Value::Object(map)\n\
     \x20       }\n\
     \x20       _ => serde_json::Value::Null,\n\
     \x20   }\n\
     }\n\n"
        .to_string()
}

/// Generate the TypedSubscription wrapper struct and Stream impl.
fn generate_typed_subscription_code() -> String
{
    "pub struct TypedSubscription<T> {\n\
     \x20   inner: convex::QuerySubscription,\n\
     \x20   _phantom: std::marker::PhantomData<fn() -> T>,\n\
     }\n\
     \n\
     impl<T> TypedSubscription<T> {\n\
     \x20   pub fn new(inner: convex::QuerySubscription) -> Self {\n\
     \x20       Self { inner, _phantom: std::marker::PhantomData }\n\
     \x20   }\n\
     \x20   pub fn into_inner(self) -> convex::QuerySubscription { self.inner }\n\
     }\n\
     \n\
     impl<T: serde::de::DeserializeOwned> futures_core::Stream for TypedSubscription<T> {\n\
     \x20   type Item = anyhow::Result<T>;\n\
     \x20   fn poll_next(\n\
     \x20       self: std::pin::Pin<&mut Self>,\n\
     \x20       cx: &mut std::task::Context<'_>,\n\
     \x20   ) -> std::task::Poll<Option<Self::Item>> {\n\
     \x20       let this = self.get_mut();\n\
     \x20       match std::pin::Pin::new(&mut this.inner).poll_next(cx) {\n\
     \x20           std::task::Poll::Ready(Some(result)) => {\n\
     \x20               let typed = match result {\n\
     \x20                   convex::FunctionResult::Value(value) => {\n\
     \x20                       let json = convex_value_to_json(&value);\n\
     \x20                       serde_json::from_value(json).map_err(|e| anyhow::anyhow!(e))\n\
     \x20                   }\n\
     \x20                   convex::FunctionResult::ErrorMessage(msg) => Err(anyhow::anyhow!(msg)),\n\
     \x20                   convex::FunctionResult::ConvexError(err) => Err(anyhow::anyhow!(err.message)),\n\
     \x20               };\n\
     \x20               std::task::Poll::Ready(Some(typed))\n\
     \x20           }\n\
     \x20           std::task::Poll::Ready(None) => std::task::Poll::Ready(None),\n\
     \x20           std::task::Poll::Pending => std::task::Poll::Pending,\n\
     \x20       }\n\
     \x20   }\n\
     }\n\n"
        .to_string()
}

// =============================================================================
// String utilities
// =============================================================================

/// Capitalize the first letter of a string.
fn capitalize_first_letter(s: &str) -> String
{
    if s.is_empty() {
        return String::new();
    }

    let mut chars = s.chars();
    let first_char = chars.next().expect("Expected a character but got none");
    let rest = chars.collect::<String>();

    first_char.to_uppercase().to_string() + &rest
}

fn to_pascal_case(s: &str) -> String
{
    s.split(|c: char| !c.is_alphanumeric())
        .filter(|s| !s.is_empty())
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(first) => first.to_uppercase().collect::<String>() + &chars.collect::<String>(),
            }
        })
        .collect()
}

/// Convert a camelCase string to snake_case.
fn to_snake_case(s: &str) -> String
{
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() && i > 0 {
            result.push('_');
        }
        result.push(c.to_lowercase().next().unwrap_or(c));
    }
    result
}
